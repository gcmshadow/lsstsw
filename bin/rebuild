#!/bin/bash
#
# ********** DONT RUN THIS UNLESS YOU UNDERSTAND WHAT IT DOES ********
# **********             SERIOUS DAMAGE MAY OCCUR             ********
#
# Recursively build all product, starting with top-level ones listed in
# $PRODUCTS.
#
# The versiondb repository should be cloned from:
#
#   https://github.com/lsst/versiondb.git
#   git@github.com:lsst/versiondb.git
#
# For creation, use:
#
#     (mkdir versiondb; cd versiondb; git init; mkdir dep_db ver_db manifests)
#

exec_name="$(basename -- $0)"
echo "Executing $exec_name..."

set -e
VERBOSE=false

DIR=$(cd "$(dirname "$0")"; pwd)
# shellcheck disable=SC1090
. "${DIR}/../etc/settings.cfg.sh"
# shellcheck disable=SC1090
. "${DIR}/deploy"

usage() { echo "Usage: $0 [-p] [-n] [-u] [-v] [-r <ref> [-r <ref2> [...]]] [-t <eupstag>] [product1 [product2 [...]]]" 1>&2; exit 1; }

# centos 6 shipped with bash 4.1; this is the best that can be done for
# returning a value prior to bash 4.3
versiondb_head() {
  (cd "$VERSIONDB" && git rev-parse HEAD)
}

fix_tag(){
  local fixed_tag=""
  list=$(eups list "${metapkg}" | grep setup)
  # from this list I want to extract the fist match that is an eups tag
  #  - b[number]      (buildID, when using versionDB)
  #  - T[number]      (timestamp, when USE_TIMESTAMP=true)
  #  - v[num*]        (release or release candidate)
  for entry in ${list}
  do
    #echo $entry
    if [[ $USE_TIMESTAMP == true ]]; then
       if [[ $entry =~ ^[T]|^[v] ]]; then
          # https://stackoverflow.com/questions/2237080/how-to-compare-strings-in-bash
          if [ "$fixed_tag" \< "$entry" ]; then
            fixed_tag=$entry
          fi
       fi
    else
       if [[ $entry =~ ^[b]|^[v] ]]; then
          # https://stackoverflow.com/questions/2237080/how-to-compare-strings-in-bash
          if [ "$fixed_tag" \< "$entry" ]; then
            fixed_tag=$entry
          fi
       fi
    fi
  done
  if [ "${fixed_tag}" == "" ]; then 
    fixed_tag="${reference}" 
  fi
  if [[ $VERBOSE == true ]]; then
    echo "rebuild >> fixed_tag $fixed_tag for $metapkg"
  fi
  echo "${metapkg}:${fixed_tag}" >> $deployedlist
}


deploy_metapkgs_upstream() {
  deployed=()
  for product in "${PRODUCTS[@]}"; do
    metapkgsfile="${LSSTSW_BUILD_DIR}/${product}/metapkgs_upstream.txt"
    deployedlist="${LSSTSW_BUILD_DIR}/${product}_metapkgs.list"
    echo $metapkgsfile
    if [ -f "${metapkgsfile}" ]; then
      echo "Deploy metapkgs upstream for product $product"
      > $deployedlist
      while read line; do
        if [[ ! ${deployed[*]} =~ "$line" ]]; then
          metapkg=$(echo $line | awk -F ':' '{print $1}') 
          reference=$(echo $line | awk -F ':' '{print $2}')
          echo "Deploying: ./bin/deploy_distrib -t ${reference} ${metapkg}"
          eups_distrib=false
          recursive_distrib "${reference}" "${metapkg}"
          #./bin/distrib_install -t "${reference}" "${metapkg}"
          #setup "${metapkg}"
          if [[ "${eups_distrib}" == true ]]; then
            fix_tag "${reference}" "${metapkg}"
          else
            echo "${metapkg}:${reference}" >> $deployedlist
          fi
          deployed+=${line}
        fi
      done < ${metapkgsfile}
    fi
  done
}


save_infos() {
# save build info
  echo ${PRODUCTS[@]}
  echo ${refs[@]}
  prod=${PRODUCTS[0]}
  filename="${LSSTSW_BUILD_DIR}/builds/${BUILD}.info"
  echo "Product $prod" > "${filename}"
  if [[ ${#refs[@]} -eq 0 ]]; then
    # no refs have ben provided
    echo "Ref master" >> "${filename}"
  else
    # saving the reference provided for the first product
    manifestfile="${LSSTSW_BUILD_DIR}/manifest.txt"
    ref=$(cat $manifestfile | grep $prod | awk '{print $3}' | awk -F '-' '{print $1}' | tr '.' '_')
    echo "Ref ${ref}" >> "${filename}"
  fi 
}


save_build_env() {
  # saving environment information
  mkdir -p "${LSSTSW_BUILD_DIR}/builds"
  filename="${LSSTSW_BUILD_DIR}/builds/${BUILD}.env"
  echo "Saving environment information in ${filename}"

  active_env="$(mktemp)"
  ref_env="$(mktemp)"

  # saving information in environment name
  echo "Environment_name: ${LSST_CONDA_ENV_NAME}" > "${filename}"

  # generating pinned list of environment content
  conda list --explicit > "${active_env}"
  cat "${active_env}" >> "${filename}"

  # extract the git reference from the environment name
  ref="${LSST_CONDA_ENV_NAME:13}"
    
  if [[ $ref == *"."* ]]; then
    # the reference is a branch
    ref1=$(echo "${ref}" | cut -f 1 -d .)
    ref2=$(echo "${ref}" | cut -f 2 -d .)
    local_env_dir="${LSSTSW}/env/${ref1}/${ref2}"
    ENVREF="${ref2}"
  else
    # the reference is a sha1 or a tag
    local_env_dir="${LSSTSW}/env/${ref}"
    ENVREF="${ref}"
  fi

  if [ -d "${local_env_dir}" ]; then
    # searching for the saved envirronment file
    ref_file=$(find "${local_env_dir}" -name "conda*.lock*" -exec basename {} \;)
    local_env_file="${local_env_dir}/${ref_file}"
    echo -e "\\nenv_ref_file: ${local_env_file}\\n" >> "${filename}"
    grep -v "^name" "${local_env_file}" > "${ref_env}"
    # save diff in file and print it to console
    {
      echo "Differences between active anvironment and reference environment:"
      diff -B -C0 <(sort "${active_env}")  <(sort "${ref_env}") || true  # OK for this to fail
      echo "^^^^ end of diff ^^^^^^^"
    } | tee -a "${filename}"
  else
    echo "No environment file definition in ${local_env_dir}. Nothing recorded."
  fi
  rm "${active_env}"
  rm "${ref_env}"
}

PREP_ONLY=false
NO_FETCH=false
UPDATE=false
USE_TIMESTAMP=false
refs=()

while getopts ":pnur:t:v" o; do
  case "$o" in
  p)
    PREP_ONLY=true
    ;;
  n)
    NO_FETCH=true
    ;;
  u)
    UPDATE=true
    ;;
  r)
    refs+=("--ref" "$OPTARG")
    ;;
  t)
    TAG="$OPTARG"
    ;;
  v)
    VERBOSE=true
    ;;
  T)
    USE_TIMESTAMP=true
    ;;
  *)
    usage
    ;;
  esac
done
shift $((OPTIND-1))

if [[ "$#" != "0" ]]; then
  PRODUCTS=("$@")
fi

define_platform
compiler="conda-system"
config_curl

(
  # shellcheck disable=SC2154
  if [[ "${miniconda_path}" ]]; then
    # shellcheck disable=SC2154
    echo "Using local miniconda at ${miniconda_path}"
    # shellcheck disable=SC1090
    . "${miniconda_path}/etc/profile.d/conda.sh"
  fi

  # true if `lsst-build prepare` has run successfully
  PREPARED=false

  #
  # Add 128 to non-zero exit statuses if the `lsst-build prepare` subcommand has
  # completed.  This is to allow consumer scripts to be able to determine if a
  # failure in this script occurred before or after the prepare step.
  #
  cleanup() {
    local rv=$?

    [[ $rv == 0 ]] && exit
    [[ $PREPARED == true ]] && [[ $rv -lt 128 ]] && rv=$((rv + 128))

    exit $rv
  }

  trap cleanup EXIT

  flock-fd 200 || { echo "a rebuild is already in process." 1>&2; exit 1; }
  #
  # update repos.yaml file
  #
  if [[ $UPDATE == true ]]; then
    config_curl
    fetch_repos.yaml
  fi

  #
  # Prepare build
  #
  if [[ $VERSIONDB_PUSH == true ]]; then
    # do not pull from remote unless configured to push
    (cd "$VERSIONDB" && git pull --quiet)
    VERSIONDB_HEAD_PREBUILD=$(versiondb_head)
  fi

  BUILD_ID="T$(date '+%Y%m%d%H%M%S')"
  echo "$exec_name >>  using build-ID $BUILD_ID"

  ARGS=()
  if [[ $NO_FETCH == true ]]; then
    ARGS+=("--no-fetch")
  fi
  ARGS+=("--repos=${REPOSFILE}")
  ARGS+=("--exclusion-map=${EXCLUSIONS}")
  ARGS+=("--version-git-repo=${VERSIONDB}")
  if [[ $USE_TIMESTAMP == true ]]; then
    ARGS+=("--build-id=${BUILD_ID}")
  fi
  ARGS+=("$LSSTSW_BUILD_DIR")
  ARGS+=("${refs[@]}")
  ARGS+=("${PRODUCTS[@]}")

  lsst-build prepare "${ARGS[@]}"

  if [[ $VERSIONDB_PUSH == true ]]; then
    # do not push unless the head ref has changed
    [[ "$VERSIONDB_HEAD_PREBUILD" != $(versiondb_head) ]] &&
      (cd "$VERSIONDB" && git push && git push --tags)
  fi

  eval "$(grep -E '^BUILD=' "$LSSTSW_BUILD_DIR"/manifest.txt)"
  echo "# BUILD ID: $BUILD"

  save_build_env
  save_infos

  # if dependencies these need to be deployed firt with distrib_install
  deploy_metapkgs_upstream

  if [[ $PREP_ONLY == true ]]; then
    exit
  fi

  PREPARED=true

  #
  # HACK: Speed up the build by assuming EUPS caches are up-to-date
  # Make sure they really are first.
  #
  _EUPS_ASSUME_CACHES_UP_TO_DATE=0 python -c "import eups; eups.Eups()"
  export _EUPS_ASSUME_CACHES_UP_TO_DATE=1

  #
  # Execute build
  #
  lsst-build build "$LSSTSW_BUILD_DIR"

  #
  # Tag as requested
  #
  if [[ ! -z $TAG ]]; then
    eups-copy-tag "$BUILD" "$TAG"
  fi

  echo "$exec_name >>  BUILD $BUILD completed."
) 200>"$DIR/../var/run/rebuild.run"

# vim: tabstop=2 shiftwidth=2 expandtab
