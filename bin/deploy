#!/bin/bash
#
#  Deploy a standardized, standalone, lsst-build sandbox
#

SCRIPT_DIR=$(cd "$(dirname "$0")"; pwd)
# shellcheck disable=SC1090
source "${SCRIPT_DIR}/../etc/settings.cfg.sh"
#
# Source script with shared functions
# shellcheck disable=SC1090
source "${SCRIPT_DIR}/../bin/utils.sh"

LSST_EUPS_VERSION=${LSST_EUPS_VERSION:-2.1.5}
LSST_EUPS_GITREV=${LSST_EUPS_GITREV:-""}
LSST_EUPS_GITREPO=${LSST_EUPS_GITREPO:-https://github.com/RobertLuptonTheGood/eups.git}
# force Python 3
LSST_MINICONDA_VERSION=${LSST_MINICONDA_VERSION:-py37_4.8.2}
LSST_MINICONDA_BASE_URL=${LSST_MINICONDA_BASE_URL:-https://repo.continuum.io/miniconda}
LSST_GIT_VERSION=${LSST_GIT_VERSION:-2.18.0}
LSST_LFS_VERSION=${LSST_LFS_VERSION:-2.4.2}
LSST_BUILD_GITREV=${LSST_BUILD_GITREV:-master}
LSST_BUILD_GITREPO=${LSST_BUILD_GITREPO:-https://github.com/lsst/lsst_build.git}
LSST_SCIPIPECENV_GITREPO=${LSST_SCIPIPECENV_GITREPO:-https://github.com/lsst/scipipe_conda_env.git}

set -e

usage() {
  if [[ ! -z "$1" ]]; then
    print_error "$0: $1"
  fi

  # note that heredocs are prefixed with tab chars
  fail "$(cat <<-EOF

		Usage: $0 [-b] [-h] [-r]

		Specific options:
	    -b          use bleeding edge conda packages
	    -r REF      git ref in scipipe_conda_env (hash, branch, tag)
	    -P          look for an aloready installed version of conda. It will fail if none is found.
	    -h          show this message

		EOF
  )"
}


fetch_repos.yaml() {
  local ref=${1:-master}
  local output_file=${2:-$REPOSFILE}
  local repo=${3:-$REPOSFILE_REPO}

  local baseurl="https://raw.githubusercontent.com/${repo}/${ref}"

  $CURL "${CURL_OPTS[@]}" \
    -L \
    "${baseurl}/etc/repos.yaml" \
    -o "$output_file"
}

parse_args() {
  local OPTIND
  local opt

  # We are intentionally not using gnu `getopt` due to portability concerns.
  # Sadly, this means no long options without a massive amount of boilerplate.
  while getopts "bhrP" opt; do
    case "$opt" in
    b)
      BLEED_DEPLOY=true
      ;;
    h)
      usage
      ;;
    r)
      shift;
      ENVREF=$1
      ;;
    P)
      USE_EXISTING_CONDA=true
      ;;
    *)
      usage "Unknown option: ${opt}"
      ;;
    esac
  done
  shift $((OPTIND-1))
}

#
# test to see if script is being sourced or executed. Note that this function
# will work correctly when the source is being piped to a shell. `Ie., cat
# newinstall.sh | bash -s`
#
# See: https://stackoverflow.com/a/12396228
#
am_I_sourced() {
  if [ "${FUNCNAME[1]}" = source ]; then
    return 0
  else
    return 1
  fi
}



main() {
  config_curl

  BLEED_DEPLOY=false

  ENVREF=""

  USE_EXISTING_CONDA=false

  parse_args "$@"

  mkdir -p "${LSSTSW}"/{sources,build,var/run,var/log,distserver/production,etc,env}

  export PATH="${LSSTSW}/lfs/bin:${PATH}"
  export PATH="${LSSTSW}/bin:${PATH}"

  local miniconda_version=$LSST_MINICONDA_VERSION

  local deploy_mode=packages
  if [[ $BLEED_DEPLOY == true ]]; then
    # shellcheck disable=SC2034
    deploy_mode=bleed
  fi

  discover_platform

  cd "$LSSTSW"

  fetch_repos.yaml 'u/gcm/shadow'


  if [[ $USE_EXISTING_CONDA == true ]]; then
    # check which comman
    if ! type "which" > /dev/null ; then
      fail "which command not present, impossible to verify conda. Avoid using option -p to deploy miniconda"
    fi
    # check if conda is available
    if ! CONDA_PATH=$(which conda) ; then
      fail "Conda not found in PATH. Avoid using option -P to deploy miniconda."
    fi
    CONDA_DIR=$(dirname "${CONDA_PATH}")
    # activating conda
    echo "Using existing conda available at ${CONDA_DIR}"
    # shellcheck disable=SC1090
    . "${CONDA_DIR}/../etc/profile.d/conda.sh"
  else
    # install miniconda
    # shellcheck disable=SC2154
    miniconda_path="${LSSTSW}/miniconda"
    miniconda_lock="${miniconda_path}/.deployed"
    test -f "$miniconda_lock" || (
      # shellcheck disable=SC2154
      miniconda_file_name="Miniconda3-${miniconda_version}-${ana_platform}.sh"

      echo "::: Deploying ${miniconda_file_name}"

      cd sources
      $CURL "${CURL_OPTS[@]}" -# -L \
        -O "${LSST_MINICONDA_BASE_URL}/${miniconda_file_name}"

      rm -rf "$miniconda_path"
      bash "$miniconda_file_name" -b -p "$miniconda_path"

      touch "$miniconda_lock"
    )

    # shellcheck disable=SC1090 
    . "${miniconda_path}/etc/profile.d/conda.sh"

    # cleanup orphaned lock file
    local old_miniconda_pkgs_lock="${LSSTSW}/miniconda/.packages.deployed"
    [[ -e $old_miniconda_pkgs_lock ]] && rm "$old_miniconda_pkgs_lock"
  fi


  #create avanila eups conda environment, to use in case the provided environment do not have eups
  conda create -y --name eups eups -c conda-forge

  # given the imput reference, provides the correct
  # - environment Name
  # - git reference
  # - local folder where to store environemnt files
  expand_ref "${ENVREF}"

  # deplying environment
  deploy_env

  # Define EUPS_PATH depending on the environment,
  # including the last 7 characters of the environment name
  export EUPS_PATH="${LSSTSW}/stack/${LSST_SPLENV_REF}"
  echo "EUPS_PATH set to ${EUPS_PATH}"

  mkdir -p "${EUPS_PATH}"/{site,ups_db}
  echo "::: Deploying manifest.remap"
  ln -sf "${LSSTSW}/etc/manifest.remap" "${EUPS_PATH}/site/manifest.remap"

  test -f "${LSSTSW}/versiondb/.deployed" || ( # Clone the version database
    echo "::: Deploying versiondb"
    rm -rf versiondb
    git clone "$VERSIONDB_REPO" versiondb

    git config -f versiondb/.git/config user.name "LSST DATA Management"
    git config -f versiondb/.git/config user.email "dm-devel@lists.lsst.org"
    git config -f versiondb/.git/config push.default current
    touch "${LSSTSW}/versiondb/.deployed"
  )

  # Clone lsst_build
  if [[ ! -f "${LSSTSW}/lsst_build/.deployed" ]]; then
    (
      echo "::: Deploying lsst_build"
      rm -rf lsst_build
      git clone "$LSST_BUILD_GITREPO" -b "$LSST_BUILD_GITREV" lsst_build
      (cd lsst_build && git config push.default current)
      touch "${LSSTSW}/lsst_build/.deployed"
    )
  else
    (
      echo "::: Updating lsst_build"
      cd lsst_build
      git fetch -fup origin "$LSST_BUILD_GITREV"
      # attempt to determine if this is a branch name or a commit id. If it is
      # a branch name, we need to reset to the commit id in the origin repo.
      # Otherwise, if the branch already exists in the clone, the local HEAD
      # will be used.
      if ! commit=$(
        git rev-parse \
          --verify \
          --quiet \
          "origin/${LSST_BUILD_GITREV}"
        ); then
        commit=$LSST_BUILD_GITREV
      fi
      git reset --hard "$commit"
    )
  fi

  echo ""
  echo "::: Deploy completed."
  echo "::: To activate the just deployed environment use the following command:"
  echo

  if [[ $ENVREF == '' ]]; then
    if [[ $SHELL =~ bash$ ]]; then
      echo "    . ${LSSTSW}/bin/envconfig"
    elif [[ $SHELL =~ csh$ ]]; then # Supports tcsh
      echo "    source ${LSSTSW}/bin/envconfig.csh"
    elif [[ $SHELL =~ zsh$ ]]; then
      echo "    . ${LSSTSW}/bin/envconfig"
    else
      echo "    The setup script in ${LSSTSW}/bin most appropriate for ${SHELL}"
      echo "    (Warning: ${SHELL} is an unsupported shell)"
    fi
  else
    echo "    . ${LSSTSW}/bin/envconfig -n ${LSST_CONDA_ENV_NAME}"
    echo ""
    echo "::: or choose the environment to activate using:"
    echo "    . ${LSSTSW}/bin/envconfig -i"
  fi

}

#
# support being sourced as a lib or executed
#
if ! am_I_sourced; then
  main "$@"
fi

# vim: tabstop=2 shiftwidth=2 expandtab
