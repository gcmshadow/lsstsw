#!/bin/bash

#
# ********** DONT RUN THIS UNLESS YOU UNDERSTAND WHAT IT DOES ********
# **********             SERIOUS DAMAGE MAY OCCUR             ********
#
# Generate and publish tarball built packages for $PRODUCTs and their dependencies
#
# $ tarballs-publish [-b <build_id>] [-t <distservtag>] [product1 [product2 [...]]]
#
# Example:
#    'publish -t current' will publish the build found in $LSSTSW_BUILD_DIR
#    and tag it as 'current' on the distribution server
#
# ------------------------------------------------------------------------
# the publish is done in 2 steps:
# 1- the packages are published in a local TMP_PKGROOT
#      TMP_PKGROOT is set to a folder inside lsstsw and cleaned before each use
# 2- the packages are published to the EUPS_PKGROOT
#      EUPS_PKGREPO shall be defined in the environemnt where the script is executed
#      it can be:
#      - a local folder (used mainly for debug) 
#      - a remote aws s3 bucket
#      The packages will be publish to ${EUPS_PKGREPO}/stack/src


DISTRIBTAG=
first_product=
NAMESPACE=false
VERBOSE=false
EUPSVERBOSE=""
EXTRA_TAG=""

set -e
DIR=$(cd "$(dirname "$0")"; pwd)
# shellcheck disable=SC1090
. "${DIR}/../etc/settings.cfg.sh"
# Source script with shared functions
# shellcheck disable=SC1090
source "${LSSTSW}/bin/utils.sh"

TMP_PKGROOT=$LSSTSW/tmp_tarballs

usage() { echo "Usage: $0 [-n] [-t <distservtag>] <product1> [product2 [...]]" 1>&2; exit 1; }


# define architecture and platform the build is done
define_platform() {

  case $(uname -s) in
    Linux*)
      pkg_postfix='linux-64'
      local release_file='/etc/redhat-release'
      if [[ ! -e $release_file ]]; then
         print_error "unknown osfamily"
         #[[ $__debug == true ]] && print_error "unknown osfamily"
      fi
      osfamily="redhat"

      # capture only major version number because "posix character classes"
      if [[ ! $(<"$release_file") =~ release[[:space:]]*([[:digit:]]+) ]]; then
         print_error "unable to find release string"
         #[[ $__debug == true ]] && print_error "unable to find release string"
      fi
      osrelease="${BASH_REMATCH[1]}"
      case $osrelease in
        7)
          osplatform=el7
          ;;
        8)
          osplatform=el8
          ;;
        *)
          print_error "unsupported release: $osrelease"
          #[[ $__debug == true ]] && print_error "unsupported release: $__release"
          # no publish
          exit 1
          ;;
        esac
      ;;
    Darwin*)
      osfamily="osx"
      pkg_postfix='osx-64'

      if ! release=$(sw_vers -productVersion); then
         print_error "unable to find release string"
         #[[ $__debug == true ]] && print_error "unable to find release string"
      fi
      osrelease=$(trimws "$release")
      case $osrelease in
        # XXX bash 3.2 on osx does not support case fall-through
        10.9.* | 10.1?.* | 10.1?)
          osplatform=10.9
          ;;
        *)
          print_error "unsupported release: $osrelease"
          #[[ $__debug == true ]] && print_error "unsupported release: $osrelease"
          # no publush
          exit 1
          ;;
        esac
      ;;
    *)
      print_error "unknown osfamily"
      #[[ $__debug == true ]] && print_error "unknown osfamily"
      # no publish
      exit 1
      ;;
  esac
  echo
  echo "tarballs-publish >> Platform parameters for binary identification:"
  echo "  -  os-family: ${osfamily}"
  echo "  -  os-release: ${osrelease}"
  echo "  -  os-platform: ${osplatform}"
  echo "  -  pkg_postfix: ${pkg_postfix}"
}


##### main #####
while getopts "ndve:t:" o; do
  case "$o" in
  n)
    NAMESPACE=true
    ;;
  t)
    DISTRIBTAG="$OPTARG"
    ;;
  d)
    DEBUG=true
    ;;
  v)
    VERBOSE=true
    ;;
  e)
    EUPSVERBOSE="$OPTARG"
    ;;
  *)
    usage
    ;;
  esac
done
shift $((OPTIND-1))

if [[ $# -eq 0 ]]; then
  usage
fi

config_curl

if [[ $VERBOSE == true ]]; then
  echo "[---- VERBOSE  ----]"
fi

case "$EUPSVERBOSE" in
  "1")
    VOPT="-v"
    ;;
  "2")
    VOPT="-vv"
    ;;
  "3")
    VOPT="-vvv"
    ;;
  *)
    VOPT=""
    ;;
esac

# unset following variable that may affect the outcome of the build
run unset EUPS_PKGROOT

# TO-DO: check that the required input parameters are provided
#  - tag
#  - products
#  - EUPS_PKGREPO
  DISTRIB_PRODUCTS=("$@")
  for prod in "${DISTRIB_PRODUCTS[@]}"; do
    # save the first product to look for manifest
    if [[ -z "${first_product}" ]]; then
      first_product=$prod
    fi
    if [[ -z "$prod" ]]; then
      echo "zero length product names are not permitted"
      usage
    fi
    if [[ $prod == *[[:space:]]* ]]; then
      echo "white spaces are not permitted in product names"
      usage
    fi
  done

# given the tag and EUPS_PKGREPO identify the ENVREF
  if [ "${NAMESPACE}" = true ]; then
    LIST_BASE_URL="${EUPS_PKGREPO}/stack/${first_product}/src/tags"
  else
    LIST_BASE_URL="${EUPS_PKGREPO}/stack/src/tags"
  fi
  LIST_URL="${LIST_BASE_URL}"/"${DISTRIBTAG}".list
  # check if it is not an https link
  if [[ "${LIST_URL:0:4}" != "http" ]]; then
    # in this case the provided repo URL has to be an absolute path
    if [[ "${LIST_URL:0:1}" == "/" ]]; then
      # sanity check on the provided path
      LIST_URL="file://${LIST_URL}"
    else
      fail "Error defining EUPS_PKGROOT: provided wrong input in EUPS_PKGREPO:\\n -> ${EUPS_PKGREPO}"
    fi
  fi
  echo
  # shellcheck disable=SC2028
  echo "tarballs-publish >> Looking for environment information from:"
  echo "  --> ${LIST_URL}"
  set +e
  RAW_ENV_INFO=$("${CURL}" -s "${LIST_URL}" | grep CONDA_ENV)
  set -e
  if [ -z "${RAW_ENV_INFO}" ]; then
    fail "Tag ${DISTRIBTAG} not available in the SRC package repository."
  fi
  RAW_ENV_REPO=$(echo "${RAW_ENV_INFO}" | awk -F '=' '{ print $2 }')
  ENVREF=$(echo "${RAW_ENV_REPO}" | awk -F '@' '{ print $2 }')
  LSST_CONDA_ENV_NAME="${SPLENV_BASE_NAME}-${ENVREF}"
  EXTRA_TAG=$("${CURL}" -s "${LIST_URL}" | grep ^#EXTRA_TAG | awk -F '=' '{print $2}')
  echo "ExtraTag '$EXTRA_TAG'"

# activate the correct environmen 
  echo
  echo "tarballs-publish >> Environment $LSST_CONDA_ENV_NAME used for eups tag $DISTRIBTAG (envref $ENVREF)."
  if [[ $EXTRA_TAG != "" ]]; then
    echo "$0 >> Distribution tagged also as '$EXTRA_TAG'."
  fi
  # shellcheck disable=1090
  source "$LSSTSW/bin/envconfig" -r "$ENVREF"
  # remove config.txt files from stack to avoid conflicts in publication
  # run find "${EUPS_PATH}" -name config.txt | xargs rm

  if [[ $DEBUG == true ]]; then
	cat <<-EOF
	----------------------------------------------------------------
	$(print_settings)
	----------------------------------------------------------------
	EOF
  fi


# install the product from source pkgs using eups distrib install -t TAG DISTRIB_PRODUCTS
  # set local (empty) pkgroot
  run rm -rf "${TMP_PKGROOT}"
  run mkdir -p "${TMP_PKGROOT}"
  deployed=()
  echo
  echo "tarballs-publish >> Install products" "${DISTRIB_PRODUCTS[@]}" "from eups source packages"
  for product in "${DISTRIB_PRODUCTS[@]}"; do
    if [ "${NAMESPACE}" = true ]; then
      # check and deploy dependencies if any
      srcdepfile="${EUPS_PKGREPO}/stack/${product}/src/metapkgdeps/${DISTRIBTAG}.list"
      if [[ "${srcdepfile:0:4}" != "http" ]]; then
        srcdepfile="file://${EUPS_PKGREPO}/stack/${product}/src/metapkgdeps/${DISTRIBTAG}.list"
      fi
      metapkgsdeps="${TMP_PKGROOT}/${product}/metapkgdeps/${DISTRIBTAG}_metapkgs.list"
      run mkdir -p $(dirname $metapkgsdeps)
      if "${CURL}" -s "${srcdepfile}" --output "${metapkgsdeps}" 2>/dev/null; then
        if [[ $EXTRA_TAG != "" ]]; then
          cp "${metapkgsdeps}" "${TMP_PKGROOT}/${product}/metapkgdeps/${EXTRA_TAG}_metapkgs.list"
        fi
        while read line; do
          if [ "${line:0:1}" != "#" ] && [[ ! ${deployed[*]} =~ "$line" ]]; then
            metapkg=$(echo $line | awk -F ':' '{print $1}')
            reference=$(echo $line | awk -F ':' '{print $2}')
            echo "Deploying: ./bin/deploy_distrib -t ${reference} ${metapkg}"
            recursive_distrib "${reference}" "${metapkg}"
            #setup "${metapkg}"
            deployed+=${line}
          fi
        done < ${metapkgsdeps}
      else
        # in case there are no deps, I don't want to let the corresponding folder in the distribution
        rm -rf $(dirname $metapkgsdeps)
      fi
      run eups distrib install --server-dir "${EUPS_PKGREPO}/stack/${product}/src" -t "${DISTRIBTAG}" "${product}" "${VOPT}"
    else
      run eups distrib install --server-dir "${EUPS_PKGREPO}/stack/src" -t "${DISTRIBTAG}" "${product}" "${VOPT}"
    fi
  done

  if [[ $VERBOSE == true ]]; then
    echo
    echo "tarballs-publish >>  EUPS Environment Variables"
    env | grep EUPS
    echo "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  fi

  echo
  echo "tarballs-publish >> Generate tarballs for products" "${DISTRIB_PRODUCTS[@]}"
  if [ "${NAMESPACE}" = true ]; then
    for product in "${DISTRIB_PRODUCTS[@]}"; do
      run eups distrib create --server-dir="${TMP_PKGROOT}/${product}" -d tarball -t "$DISTRIBTAG" "$product" "${VOPT}"
      # Declare the build tag, and declare it $DISTRIBTAG, if set
      run eups distrib declare --server-dir="${TMP_PKGROOT}/${product}" -t "$DISTRIBTAG" "${VOPT}"
      if [[ $EXTRA_TAG != "" ]]; then
        echo "tarballs-publish >> Adding tag '${EXTRA_TAG}' at the distribution server."
        match="EUPS distribution ${DISTRIBTAG} version list. Version 1.0"
        echo "MATCH: '$match'"
        sub="EUPS distribution ${EXTRA_TAG} version list. Version 1.0"
        echo "SUB: '$sub'"
        dst_tag="${TMP_PKGROOT}/${product}/${DISTRIBTAG}.list"
        echo $dst_tag
        extra_tag="${TMP_PKGROOT}/${product}/${EXTRA_TAG}.list"
        echo $extra_tag
        sed -r "s|${match}|${sub}|" "$dst_tag" > "${extra_tag}"
      fi
    done
  else
    for product in "${DISTRIB_PRODUCTS[@]}"; do
      run eups distrib create --server-dir "${TMP_PKGROOT}" -d tarball -t "$DISTRIBTAG" "$product" "${VOPT}"
    done
    # Declare the build tag, and declare it $DISTRIBTAG, if set
    run eups distrib declare --server-dir="${TMP_PKGROOT}" -t "$DISTRIBTAG" "${VOPT}"
  fi

# publish the binaries packages
  define_platform
  compiler="conda-system"

  if [[ ! -z $EUPS_PKGREPO ]]; then
    # push to final PKGROOT enabled
    if [ "${NAMESPACE}" = true ]; then
      for product in "${DISTRIB_PRODUCTS[@]}"; do
        echo "EnvRef '${ENVREF}'"
        deploy_destination="stack/${product}/${osfamily}/${osplatform}/${compiler}/${ENVREF}/"
        echo
        echo "tarballs-publish >> Publishing to filesystem: ${EUPS_PKGREPO}/${deploy_destination}"
        if [[ "${EUPS_PKGREPO:0:4}" != "http" ]]; then
          # the PKGROOT is a local filesystem
          run mkdir -p "${EUPS_PKGREPO}/${deploy_destination}"
          run cp -r "${TMP_PKGROOT}/${product}/." "${EUPS_PKGREPO}/${deploy_destination}"
        else
          # the PKGROOT is a remote aws s3
          echo "To Be Implemented."
        fi
      done
    else
      deploy_destination="stack/${osfamily}/${osplatform}/${compiler}/${ENVREF}/"
      echo
      echo "tarballs-publish >> Publishing to filesystem: ${EUPS_PKGREPO}/${deploy_destination}"
      if [[ "${EUPS_PKGREPO:0:4}" != "http" ]]; then
        # the PKGROOT is a local filesystem
        run mkdir -p "${EUPS_PKGREPO}/${deploy_destination}"
        run cp -r "${TMP_PKGROOT}/." "${EUPS_PKGREPO}/${deploy_destination}"
      else
        # the PKGROOT is a remote aws s3
        echo "To Be Implemented."
      fi
    fi
  else
    echo
    echo "tarballs-publish >> Publishing disabled. No EUPS_PKGREPO env var defined."
  fi 

# vim: tabstop=2 shiftwidth=2 expandtab
